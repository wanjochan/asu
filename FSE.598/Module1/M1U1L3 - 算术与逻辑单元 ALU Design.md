## 1. 二进制与十进制的转换
- **方法**：使用**短除法**将十进制转为二进制。
  - **过程**：不断除以 2，记录余数，直到商为 0，余数从下往上读。
  - **示例**：19 → 19 ÷ 2 = 9 余 1 → 9 ÷ 2 = 4 余 1 → 4 ÷ 2 = 2 余 0 → 2 ÷ 2 = 1 余 0 → 1 ÷ 2 = 0 余 1 → 二进制为 **10011**。

## 2. 二进制加法
- **规则**：
  - 0 + 0 = 0
  - 0 + 1 = 1
  - 1 + 0 = 1
  - 1 + 1 = 0（进位 1）
  - 1 + 1 + 1 = 1（进位 1）
- **特点**：类似十进制加法，但仅使用 0 和 1，需关注进位。

## 3. ALU（算术逻辑单元）设计
- **功能**：执行算术运算（如加、减、乘、除）和逻辑运算（如与、或、非、异或）。
- **操作**：
  - **算术**：
    - 加法
    - 减法（通过补码加法实现）
    - 乘法
    - 除法
  - **逻辑**：
    - AND（与）
    - OR（或）
    - NOT（非）
    - XOR（异或）
  - **分支**：
    - 相等时分支（branch on equal）
    - 不相等时分支（branch on not equal）
    - 小于则置位（set on less than）
- **结构**：
  - 32 位 ALU 由 32 个单位置理器组成。
  - 每位支持与、或、加法等操作。
  - **加法器**：串联实现，进位从低位传到高位。
  - **减法**：将减数取 2 的补码后进行加法。
  - **控制线**：4 条控制线选择 16 种运算。

## 4. 补码
- **定义**：
  - **1 的补码**：每位取反（0 → 1，1 → 0）。
  - **2 的补码**：1 的补码加 1。
- **用途**：表示负数，实现减法（A - B = A + (-B)）。

## 5. 乘法设计
- **原理**：通过加法和移位实现。

- **硬件实现流程（带加法和右移的乘法器）**：

总结：把乘数放低位，每次看最低位：是1就加被乘数到高位，然后整体右移一位。"

例一：  以 6 × 5 为例：

- **被乘数**：0000 0110 (6)
- **乘数**：0000 0101 (5)
- **初始寄存器**：0000 0000 0000 0101

| 步骤 | 积（高8位） | 乘数（低8位） | 末位 | 操作         | 右移后寄存器内容      |
|------|-------------|--------------|------|--------------|----------------------|
| 0    | 0000 0000   | 0000 0101    | 1    | 加被乘数     | 0000 0011 0000 0010  |
| 1    | 0000 0011   | 0000 0010    | 0    | 不加         | 0000 0001 1000 0001  |
| 2    | 0000 0001   | 1000 0001    | 1    | 加被乘数     | 0000 0011 1100 0000  |
| 3    | 0000 0011   | 1100 0000    | 0    | 不加         | 0000 0001 1110 0000  |
| 4    | 0000 0001   | 1110 0000    | 0    | 不加         | 0000 0000 1111 0000  |
| 5    | 0000 0000   | 1111 0000    | 0    | 不加         | 0000 0000 0111 1000  |
| 6    | 0000 0000   | 0111 1000    | 0    | 不加         | 0000 0000 0011 1100  |
| 7    | 0000 0000   | 0011 1100    | 0    | 不加         | 0000 0000 0001 1110  |

- **最终结果**：0000 0000 0001 1110（二进制）= 30（十进制）

---
例二
- 以 13 × 11 为例：
  - 被乘数 = 0000 1101 (13)
  - 乘数 = 0000 1011 (11)
  - 初始：积/乘数寄存器 = 0000 0000 0000 1011

| 步骤 | 积（高8位） | 乘数（低8位） | 末位 | 操作         | 右移后寄存器内容      |
|------|-------------|--------------|------|--------------|----------------------|
| 0    | 0000 0000   | 0000 1011    | 1    | 加被乘数     | 0000 1101 0000 0101  |
| 1    | 0000 1101   | 0000 0101    | 1    | 加被乘数     | 0001 1010 1000 0010  |
| 2    | 0001 1010   | 0000 0010    | 0    | 不加         | 0000 1101 0100 0001  |
| 3    | 0000 1101   | 0000 0001    | 1    | 加被乘数     | 0001 1010 1000 0000  |
| 4    | 0001 1010   | 0000 0000    | 0    | 不加         | 0000 1101 0100 0000  |
| 5    | 0000 1101   | 0000 0000    | 0    | 不加         | 0000 0110 1010 0000  |
| 6    | 0000 0110   | 0000 0000    | 0    | 不加         | 0000 0011 0101 0000  |
| 7    | 0000 0011   | 0000 0000    | 0    | 不加         | 0000 0001 1010 1000  |

- 最终结果：0000 0001 1010 1000（二进制）= 143（十进制）

程序化理解：
```python
def format_binary(num, width=8):
    """Format a number as binary string with specified width."""
    return format(num, f'0{width}b')

def binary_multiplication_demo(multiplicand, multiplier):
    """Demonstrate binary multiplication process step by step."""
    # Initialize the product register (16 bits total)
    product_high = 0  # High 8 bits
    product_low = multiplier  # Low 8 bits (initially the multiplier)
    
    # Print table header
    print("| 步骤 | 积（高8位） | 乘数（低8位） | 末位 | 操作         | 右移后寄存器内容      |")
    print("|------|-------------|--------------|------|--------------|----------------------|")
    
    # Process 8 steps
    for step in range(8):
        # Get the least significant bit
        lsb = product_low & 1
        
        # Store original values for display
        orig_high = product_high
        
        # Add multiplicand if LSB is 1
        if lsb:
            product_high = (product_high + multiplicand) & 0xFF  # Keep 8 bits
            operation = "加被乘数"
        else:
            operation = "不加"
        
        # Right shift the entire 16-bit register
        combined = (product_high << 8) | product_low
        combined >>= 1
        product_high = (combined >> 8) & 0xFF
        product_low = combined & 0xFF
        
        # Format output
        print(f"| {step:<4} | {format_binary(orig_high):<11} | {format_binary(product_low):<12} | {lsb:<4} | {operation:<10} | {format_binary(product_high, 8)} {format_binary(product_low, 8)}  |")

# Example from the table: multiplicand = 13 (0000 1101), multiplier = 11 (0000 1011)
print("演示 13 (0000 1101) × 11 (0000 1011) 的二进制乘法过程：\n")
binary_multiplication_demo(13, 11) 

print("\n演示 6 * 5 的二进制乘法过程：\n")
binary_multiplication_demo(6, 5) 
```
---

## 6. 除法设计
- **原理**：通过减法和移位实现。
- **硬件实现**：
  - 被除数和除数存寄存器。
  - 每次尝试减除数：
    - 若结果非负，记录 1 并继续；
    - 若负，恢复并记录 0。
  - **优化**：用 32 位 ALU 迭代 32 次，结果存 64 位（商 32 位 + 余数 32 位）。
- **示例**：6 ÷ 2 = 3（商），余数 0
  - 被除数：0110，除数：0010。
  - 逐步左移并尝试减法，最终商为 0011，余数为 0000。

## 7. 性能分析
- **加法/减法**：单步完成，速度快。
- **乘法/除法**：需迭代 32 次，速度慢。
- **建议**：编程时优先使用加减法优化性能。

---

# 记忆与备考建议
- **重点记忆**：
  - 二进制转换的短除法步骤。
  - 二进制加法规则及进位处理。
  - ALU 的功能、结构和控制线作用。
  - 补码的计算方法及其在减法中的应用。
  - 乘法和除法的硬件实现步骤。
- **理解关键**：
  - ALU 如何通过补码实现减法。
  - 乘除法为何比加减法耗时更多。
- **复习方法**：
  - 手动演算二进制加法、乘法、除法示例。
  - 结合视频中的案例，理解硬件执行流程。
  - 绘制 ALU 结构图，加深对设计的印象。

---
